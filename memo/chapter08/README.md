# ８章まとめ

## 並行プログラミング
* ７章の並行処理は短いので飛ばした
* 後述のプロセスにまとめる

## プロセス
* OSのプロセスとは別である
* プロセスの生成および破棄は高速
* プロセス間のメッセージ送信も高速
* プロセス間のメッセージ送信はメッセージパッシングと呼ばれ、これのみでやりとりをする
* プロセス間のメモリ共有を行わない
* プロセスは独立していて、Erlangの関数を評価をできる仮想マシンである

## 並行処理の書き方
* プロセスがメッセージを受け取った時の処理の記述(関数)
* プロセスの生成(上記の処理を受け取る)→プロセスIDの返却
* プロセス(ID)へのメッセージ送信

### 例を見ての疑問
* メッセージを受け取った時の処理以外の処理はどうするのか？
* 複数でのプロセス間でのやりとりはどうするのか？

## 複数でのプロセス間でのやりとり
* (サーバ側)プロセス生成時に渡す処理内では、(クライアント側の)Pidも受け取りそのPidに対してメッセージを返す
* 上記の生成されたプロセス(サーバ側)に対して、(クライアント側の)Pidとともにメッセージを送信する

## 受け取ったが処理していないメッセージ
* キューに残る
* receiveにこのキューを操作する選択受信という機能があるらしい

## プロセスの生成と時間
* erlang:system_info(process_limit)
* statistics(runtime)
* statistics(wall_clock)
* erl +P user_define_process_limit
* 経過時間の取得とプロセス数の増減を行える

## タイムアウト付きの受信
* ずっと受信待ちになることを防ぐためにある
* 一定時間待つだけの処理をsleepとして使うことも出来る
* 一定時間後だけに処理をするタイマーとして使うことも出来る
* 即座にタイムアウトすることもできる
* プロセスのメールボックス？前述のキュー？
* タイムアウト時の処理にreceiveを書くことが出来る

### タイムアウトが無制限
* アトム infinity は特別であり、文字通りの効果がある

## 選択受信
* プロセスとsend, receive, メールボックス, キューの関係
* とても重要っぽい感じがするのできちんとまとめる

1. メッセージの送信をすると、そのプロセスのメールボックスへ送られる
2. プロセスが実行されると、メールボックスからメッセージを取り出しパターン照合を行う(afterがあればそれを開始する
3. パターン照合しなかったときに、キューに保存される
4. メッセージから次のメッセージに対してパターン照合を行う
5. メールボックスが空になったとき、次のメッセージをうけとったときにプロセスが実行される
6. パターン照合したとき、およびafterのタイマ実行時には、キューに保存されたメッセージはメールボックスに戻される

## 登録済みプロセス
* プロセス間でのやりとりをするにはPIDを知っておく必要がある
* そのための仕組み

## 並行プログラムのテンプレート
* startでプロセスの生成
* 上記で、実行する処理をloop関数として定義する
* 上記のプロセスにメッセージを送るにはrpc関数を定義する
* PIDとリクエストメッセージを渡し、同じPIDからのレスポンスを返す
* ここから始めて、rpcをラップしたりしながらコードを書く

## MFAとspawn
* Module, Function name, Argument list
* 固定引数でなく動的に引数の内容を使う場合にはspawn/3(引数は上記３つ)を使う
* applyと同じ構造
