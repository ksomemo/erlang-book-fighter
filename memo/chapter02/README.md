# ２章まとめ

## 式
* ピリオドをつけて末尾を示す
* よく忘れる

## コメント
* %で以降がコメントになる
* ただし、%%を行コメントとして扱うのが習慣らしい

## 変数
* 再代入禁止は他の言語と同じ
* ただし、代入ではない
* パターン照合演算子

## パターン照合
* 未定義の変数を使おうとすると未束縛と言われる
* 束縛済みの場合、再代入できない
* 上記は正しくなく、同じ値を代入すると問題ない
* 上記も正しくなく、束縛したときの値と再束縛しようとしたときの値が同じであれば良い

## 状態の変更をどう処理するのか
* 新しく束縛する
* プログラムの見通し良くするためにはHaskellのように型を使っていくのか？
* 関数型プログラミングと型についてはよくわかっていない

## アトムと文字列
* クォートで囲まれていない空白なしの小文字から始まる文字列はアトムである
* 返す値は入力したそのものである
* シングルクォートで囲まれた大文字から始まる文字列もアトムである
* Erlangとしての文字列との違いをきちんと調べる

## タプル
* タプルも使える(pairという言葉は出てきてなく、いくつでも要素を作れそう)
* 入れ子に出来る
* あるタプルと同じ構造をもつのであれば、パターン照合を使って変数を分解しながら束縛できる
* 明示的な型宣言がないので、型名としてタプルの最初の要素にアトムして型名をつける
* 上記２つを利用することで、型としてのアトムも照合することで安全に束縛できる

## リスト
* Haskellと同じで、[]で囲んでカンマ区切り
* Haskellと同じで、パターン照合を使ってHeadとTailに分けられる(HEAD|TAIL)
* x1:x2:xsのようにするには, X1,X2|XS

## 文字列
* ダブルクォートで囲む
* リストの数字要素が文字として表せるとき、文字列として表示される
* 文字列は文字列として表示される
* $単一文字 と入力すると対応する数字が表示される(日本語も大丈夫だった)

## 文字列とアトム
* そのまえに比較は == で行う
* true/falseで結果が表示される(これらはアトムであるが論理値として扱われる)
* a == "a". % => false, よりアトムと文字列は異なる
* これは数字リストと文字列が同じであるが、アトムはアトムであることがわかる

## その他
* すごいErlangのほうが基礎部分は丁寧に教えてくれていると思う
* 再束縛できないので、erl（REPL）ではf()を使って、束縛をなくすので積極的に使いたい
