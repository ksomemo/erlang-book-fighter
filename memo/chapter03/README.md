# ３章まとめ

## モジュール
* -xxx はアノテーションらしい
* functionName(args) -> process
* REPLでのコンパイルは c(moduleName)
* moduleName:functionName()

## REPLでのディレクトリ移動
* pwd()で調べて
* cd('xxx')で移動

## 関数
* 関数を呼び出す際は、アリティと引数の内容によるパターン照合が行われる
* アリティが同じだが引数の内容が違うときの関数定義は、最後の関数定義以外はセミコロンを終端とする
* 関数名が同じだがアリティが違うときは、ピリオドをつける
* これは、１つめの場合は関数定義を多数しているのではなくパターンを列挙しているため

## ラムダ式
* fun(args) -> process end.
* 上記を変数に束縛すると関数として評価される
* 名前付きと同様パターン照合のために複数パターンを列挙できる

## 高階関数
下記は、関数を返す関数を実行して、さらに実行する例である
```
F1 = fun(F) -> (F(2))() end.
F2 = fun(X) -> (fun() -> 2 * X end) end.
F1(F2). %% => 4
```

* 関数を返す関数のendのあとにはピリオドをつけない
* 関数を2重で実行する際はカッコをつける必要がある
* listsモジュールにはmap,filterといった他の言語でもお馴染みの関数が揃っている

## リスト内包表記
```
[2 * X * Y || X <- [2,3,4], Y <- [5,6,7], X rem 2 =:= 0].
%% => [20,24,28,40,48,56]
[X || L <- [[1,2],[3,4]], X <- L].     
%% => [1,2,3,4]
```

* 組み合わせ可能
* 条件付き可能
* 2重での使い方も可能

## 比較
リスト内包表記での条件付けで出てきた演算子について簡単に記載する

* 0 =:= 0.0.  %% => false
* 0 =:= 0.    %% => true
* 0 == 0.0.   %% => true

これより、=:=での比較は厳密に比較を行うことがわかる
また、falseになりそうな値を調べてみた

* 0 == ''.    %% => false
* 0 == "".    %% => false
* 0 == false. %% => false

空アトム？、空文字、false、といった値とは同じにならなかったので緩くはない
基本は厳密に比較を行うように習慣づけて、比較のまとめを見つけてみたい

## 論理和と論理積
* (0 == 0) or (1/0 > 2).      %% => error
* (0 == 0) orelse (1/0 > 2).  %% => true
* (0 == 1) and (1/0 > 2).     %% => error
* (0 == 1) andalso (1/0 > 2). %% => false

これより、or,andは先の評価でtrue,falseの結果が分かっていても、評価を続行する

## ガード列とif式
パターン照合をさらにサポートする条件づけのこと。

* guard -> process.
```
%% orelse
if
    1 =:= 0; 0 =:= 0 -> 1;
    0 =:= 0 -> 2
end.
%% => 1
%% ------
%% andalso
if
    1 =:= 0, 0 =:= 0 -> 1;
    0 =:= 0 -> 2
end.
%% => 2
```

* 式なので値を返す 
* or,andでガードを書くとエラーとなった時、エラーにはならないが次のガードの評価に移行する

### 関数でのガード
* なぜかShellでは下記が syntax error before: 'when'となる…
* モジュール内に書くとコンパイルが通る
```
functionName(X) when X == 1 -> true;
functionName(X) false.
```

## レコード（名前付きタプル）
* 確実性を保つためにはheader ファイルとして作成するべきらしい
* モジュールではないのでc()ではなく、rr("fileName.ext"). で読み込む
* その他レコードに関するshellコマンドはhelp().を参照
* keyと対応するvalueを定義する
* レコードの作成時には各keyに対応する値を与えることができる
* valueが与えられなかった場合、定義したときのvalueがdefault値となり、定義がない場合はundefined(アトム)になる
* 作成済みレコードからレコードを作成することができ、一部の値を変更しながら作成することができる(valName\#recordName{key=val})
* 値はパターン照合を使うか、recordName.keyで取り出す
* レコードの定義を消すとkeyが消えてタプルになるが、indexを指定して取り出すような操作はできなかった


## case式
* パターン照合だけでつらいときには前述のif式やcase式を使う
* if式はtrueというガードでdefault値を返すが、case式では最小のパターンを考える必要がある
