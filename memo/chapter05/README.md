# ５章まとめ

## バイナリ
* <<0~255[, 0~255, ...]>>
* term_to_binary(Term)、binary_to_term(Bin)がASCII範囲外でも変換してくれるので便利そう
* termはspecによると任意のデータ型、なので便利そうである

## spec
* 型記法
* 前回書いたspecについては付録に記載されている
* @spec は古い書き方なので、-specにすること

## ビット
```
<<3:3,2:2,3:3>>. %% => <<"s">>
$s.              %% => 115
2#01110011.      %% => 115
```

* 1byteに対して、3・2・3 bitで分割し、それぞれにその数字を割り当てている
* sとして表示されたが、10進数表記への変換及び、2進数表記から変換より意図がわかるようになっている

```
<<3:3,2:3,3:3>>. %% => <<105,1:1>>
2#011010011.     %% => 211
2#01101001.      %% => 105
```

* 2bitであったところを3bitに変更した
* 上記より、合計で1byte+1bitになっていることがわかる
* 8bitごとでないとダメというのが変わっている？
* 実際の値の部分を変数名にすることでパターン照合にも使える
* bitのパターン照合は関数の引数でも行える

### type specifier
* 型限定子
* :size のようにbit指定だけでなく、型指定もできる
* 組み合わせ可能である(ex. type1-type2-type3)
* いろいろあるので省略

## マクロ
* 定義は、defineアノテーションで行う
* -define(macroName, 展開される形式).
* マクロを使う(展開する)には、?macroName
* マクロの中で引数？も使えるように出来る

LL系でよくある下記もつかえる

```
__FILE__, __LINE__, __CLASS__
?FILE, ?LINE, ?MODULE
```

制御系マクロも存在する

* -ifdef
* -else
* -endif
* ほかにもいろいろ

## apply
* moduleと関数および引数を指定して実行できる
* メタプログラミングに使えそうだが、コンパイル時に解析できない
* phpのcall_user_func()に似ている構文

## 属性
* アノテーションと同じ？(moduleアノテーションとmodule属性で同じことを言っている)

### モジュール
* モジュール名とファイル名を同じにする習慣は、自動コードロード機構のため
* 上記は付録参照
* 定義済みとユーザー定義の属性がある
* 上記のどちらにもかかわらず、モジュール情報を取得する関数で使用できるメタデータとなる

#### 定義済み
* importで他のmoduleを使えるようになる
* compileで全関数のexportができるオプションがある

#### ユーザー定義
* intellijで自動作成された -author("ksomemo"). などの属性がある
* ほかにも自由に定義できるのか？

## ブロック式
* Rubyのようなブロック構文である
* しかし、複数の式を単一式としてみなす(複数の式をもって１つの値を返す)ためだけなので用途が違う

## ブール式
* 今まで出てこなかったnot, xorも存在する
* ただし、orelse, andalsoを考えると使うことはやはり少ないと思う
* 上記を短絡型ブール式という

## Erlang PreProcessor
* コンパイル前の処理
* マクロ展開やインクルードファイルの挿入

```
compile:file(moduleFile, ['fileext']).
```

* 前処理後のmoduleFile内容が出力される
* モジュール内で定義したマクロを、モジュール内で展開して使うと展開されていた
* マクロ定義やコメントは削除されていた

## エスケープシーケンス
以前出力で使ったio:formatで使ったエスケープに関して詳しく書かれている

## 関数参照
* fun ModuleName:FuncName/Arity
* 高階関数で既存関数を使う場合などに用いる

## インクルードファイル
* chapter03で扱ったレコード用のインクルードファイルを読み込む構文がある(rr()で読み込んでいた)
* -include("fileName"), これはモジュール属性ではない

## リスト
* AList -- BList は、AからBの要素を抜き取る
* "string" ++ List は、"string" という文字列を先頭に含むパターン照合として使える
* カンマ区切りのパターン照合では読みづらいのでとても便利であるが、パターン照合としてのときはパフォーマンスはどうなのか？

## プロセス辞書
* map, 辞書型, 連想配列に相当するもの
* 他言語のようなSyntaxはなく、put,getといった関数を通して値の設定及び取得を行う
* 副作用を許容するようになるらしく、著者はめったに使わないらしいので覚えておく

## リファレンス
* 一意なタグを作るらしいがよくわかっていない
* データ型の１つである

## 比較
* =:=, == に関する説明（整数と浮動小数点）
* 型の違いによる比較について書いてある
